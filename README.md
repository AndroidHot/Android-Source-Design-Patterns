:tokyo_tower: 通过 Java / Kotlin 学习设计模式

## 创建型

- [简单工厂](/simplefactory)
- [工厂方法](/factorymethod)
- [抽象工厂](/abstractfactory)
- [单例](/singleton)
- [原型](/prototype/java)
- [建造者](/builder)

## 结构型

- [适配器](/adapter)
- [桥接](/bridge)
- [组合](/composite)
- [装饰](/decorator)
- [外观](/facade)
- [享元](/flyweight)
- [代理](/proxy)

## 行为型

- [职责链](/chain)
- [命令](/command)
- [迭代器](/iterator)
- 中介者
- 备忘录
- [观察者](/observer)
- 访问者
- 策略
- 状态
- 模板方法

---

## 创建型


### [简单工厂模式](/simplefactory)

简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，是工厂模式中最简单的一种。

**优点**：
- 实现了对象创建和使用的分离

**缺点**：
- 工厂类过度复杂
- 不利于扩展和维护

**适用场景**：
- 工厂类负责创建的对象比较少
- 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。


### [工厂方法模式](/factorymethod)

工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了一些简单工
厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和 API 类库的
核心模式，在 Android 源码里也能经常看见它的身影。

**优点**：
- 实现了对象创建和使用的分离
- 易于扩展和维护

**缺点**：
- 在一定程度上增加了系统的复杂度

**适用场景**：
- 客户端不需要知道它所创建对象的类
- 在意系统的可扩展性


### [抽象工厂模式](/abstractfactory)

抽象工厂模式是工厂方法模式的进一步延伸，它提供了功能更为强大的工厂类，并且具备较好的可扩展性。

**优点**：
- 实现了对象创建和使用的分离
- 易于扩展和维护
- 增加新的产品族很方便

**缺点**：
- 增加新的产品等级结构麻烦，不完全符合“开闭原则”

**适用场景**：
- 客户端不需要知道它所创建对象的类
- 在意系统的可扩展性
- 系统中的产品族不止一个，而客户端每次只使用其中一个产品族
- 产品等级结构稳定，设计完成之后不会向系统中增加或删除产品等级结构


### [单例模式](/singleton)

确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

**适用场景**
- 客户端只需要一个实例对象


### [原型模式](/prototype)

使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**适用场景**
- 创建新对象成本较高

### [建造者模式](/builder)

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

**适用场景**
- 需要生成的对象有复杂的内部结构（eg:包含多个成员变量）
- 隔离复杂对象的创建和使用


---


## 结构型

### [适配器模式](/adapter)

适配器模式将现有接口转换为客户端所期望的接口，实现了对现有类的复用。

**适用场景**：
- 进行不兼容的类型转换
- 输入有很多种情况，但输出类型是统一的

### [桥接](/bridge)

**Wikipedia**:

> The bridge pattern is a design pattern used in software engineering that is meant to "decouple an abstraction from its implementation so that the two can vary independently"

在软件开发中如果一个类或者一个系统有多个维度变化时，可以尝试使用桥接模式对其进行设计。

### [组合模式](/composite)

组合模式使用面向对象的思想来实现树形结构的构建和处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。

**优点**：
- 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
- 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。
- 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。
- 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。

**缺点**：
- 在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。

**适用场景**：
- 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。
- 在一个使用面向对象语言开发的系统中需要处理一个树形结构。
- 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。


### [装饰模式](/decorator)

动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现的方式更加灵活。

**适用场景**：
- 在不影响其它对象的情况下，以动态、透明的方式给单个对象添加职责。
- 当不能采用继承的方法对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。


### [外观模式](/facade)

外观模式是一种使用频率非常高的设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。外观模式并不给系统增加任何新功能，它仅仅是简化调用接口。

**Wikipedia**:

> A facade is an object that provides a simplified interface to a larger body of code, such as a class library.


### [代理模式](/proxy)

给某一个对象提供一个代理，并由代理对象来控制对原对象的访问和操作。

**适用场景**：
- 控制对被代理对象的访问。
- 当创建一个对象十分消耗资源时，可以使用代理模式延迟该对象的初始化。
- 当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。


---


## 行为型


### [职责链模式](/chain)

构建一系列对象组成链，沿着这条链传递请求，直到找到合适的对象处理请求。

**适用场景**：
- 有多个对象可以处理同一个请求，具体哪个对象处理该请求在运行时确定，客户端只需要将请求提交到链上，而无须关心请求的处理对象是谁。
- 在不明确具体接收者的情况下，向多个对象中的某一个提交请求。


### [命令模式](/command)

请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。


### [迭代器模式](/iterator)

迭代器模式提供了一种访问聚合对象元素而不暴露该对象的内部表示的方式。


### [观察者模式](/observer)

定义对象之间的一种一对多的依赖关系，使得每当一个对象（被观察者）状态发生改变，其相关依赖对象（观察者）都可以收到通知并自动更新。
